<?php

/**
 * Implements hook_library_info_build().
 */
function kalastatic_library_info_build() {
  $build_file_path = \Drupal::config('kalastatic.settings')->get('kalastatic_build_path');
  $build_path = str_replace(DRUPAL_ROOT, '', $build_file_path);

  $libraries = [];
  $libraries['kalastatic'] = [
    'dependencies' => [
      'core/jquery',
    ],
    'license' => [
      'name' => 'MIT',
      'url' => 'https://opensource.org/licenses/MIT',
      'gpl-compatible' => TRUE,
    ],
    'css' => [
      'theme' => [
        $build_path . '/styles/main.css' => [],
      ],
    ],
  ];

  // Go through all the js files in the js folder and add them as part of the
  // library.
  $js_path = $build_path . '/js';
  foreach (scandir($js_path) as $key => $filename) {
    if (preg_match('/^.*\.(js)$/i', $filename)) {
      $libraries['kalastatic']['js'][$js_path . '/' . $filename] = [
        'type' => 'internal',
        'minified' => FALSE,
      ];
    }
  }

  return $libraries;
}

/**
 * Return the default path to Kalastatic
 *
 * The assumption is that it is inside a folder called 'kalastatic' in the
 * current default theme.
 */
function kalastatic_path_to_src_default() {
  $default_theme = \Drupal::config('system.theme')->get('default');
  return drupal_get_path('theme', $default_theme) . '/kalastatic';
}

/**
 * Return the path to the default build folder.
 *
 * Grep the kalastatic.yml file inside of the Kalastatic src folder and work out
 * where it's being built to.
 */
function kalastatic_path_to_build_default() {
  // TODO: Work some yaml magic.
  return kalastatic_path_to_src_default() . '/build';
}

/**
 * Implements hook_preprocess_html().
 *
 * Adds any KalaStatic-specific variables to Twig.
 */
function kalastatic_preprocess_html(&$variables) {
  // Add the build_path global variable so Twig can use it.
  if (!isset($variables['build_path'])) {
    // TODO Figure out the true destination path from kalastatic.yaml.
    $variables['build_path'] = base_path() . 'kalastatic/';
  }
}

/**
* Prepare the variables from a text_with_summary field.
 */
function kalastatic_prepare_field__text_with_summary($field, $entity) {
  $output = [];
  foreach ($entity->$field->getValue() as $i => $item) {
    $text = check_markup($item['value'], $item['format']); // TODO: langcode, cache??
    // TODO: We probably want to have an teaser option that returns the summary.
    $output[$i] = $text->__toString();
  }

  // If there's only a single image then don't return a nested array.
  return count($output) == 1 ? $output[0] : $output;
}

/**
 * Prepare the variables from an image field, ready for the image.html.twig
 */
function kalastatic_prepare_field__image($field, $entity) {
  $imgs = [];
  foreach ($entity->$field->getValue() as $i => $item) {
    if ($entity->get($field)->entity) {
      $image_url = $entity->get($field)->entity->uri->value;
    }
    else {
      $image_url = '';
    }
    $imgs[$i] = [
      'url' => file_create_url($image_url),
      'title' => $item['title'],
      'alt' => $item['alt'],
      'width' => $item['width'],
      'height' => $item['height'],
    ];
  }

  // If there's only a single image then don't return a nested array.
  return count($imgs) == 1 ? $imgs[0] : $imgs;
}

/**
 * Prepare the variables from an image field, ready for the image.html.twig
 */
function kalastatic_prepare_field__entity_reference($field, $entity, $formatter) {
  $output = [];
  foreach ($entity->$field->referencedEntities() as $i => $item) {
    if ($formatter) {
      // Caller wants the referenced entites in a specific format.
      // TODO: Can we use actual field formatters/view modes somehow?
      $func = 'kalastatic_format_' . $formatter;
      $output[$i] = $func($item);
    }
    else {
      // Otherwise just return the whole entity for manual tinkering.
      $output[$i] = $item;
    }
  }

  // If there's only a single image then don't return a nested array.
  return count($output) == 1 ? $output[0] : $output;
}

/**
 * Prepare the variables from a link field.
 */
function kalastatic_prepare_field__link($field, $entity) {
  $output = [];

  // Handle link field.


  // If there's only a single image then don't return a nested array.
  return count($output) == 1 ? $output[0] : $output;
}

/**
 * Prepare the variables from an entity to make a link like Kalastatic wants.
 */
function kalastatic_format_entity_link($entity, $text = '') {
  // TODO: extend with other attributes.
  $url = $entity->toUrl()->toString();
  $text = $text ? $text : $entity->label();
  return kalastatic_format_link($url, $text);
}

/**
 * Prepare the variables to make a link like Kalastatic wants.
 */
function kalastatic_format_link($url, $text) {
  return array(
    'url' => $url,
    'text' => $text,
  );
}

/**
 * Implements hook_twigshim_loader().
 *
 * Adds the @kalastatic namespace for Twig usage.
 *
 * @see http://twig.sensiolabs.org/doc/api.html
 */
function kalastatic_twigshim_loader($loader) {
  $source = kalastatic_path_to_kalastatic() . '/src';
  if (is_dir($source)) {
    // Add the namespaced path for the KalaStatic source.
    $loader->addPath(kalastatic_path_to_kalastatic() . '/src', 'kalastatic');
  }
}

/**
 * Implements hook_twigshim_environment().
 *
 * Adds any additional needed variables to the Twig environment.
 */
function kalastatic_twigshim_environment($twig) {
  // Expose Drupal's base_path().
  $base_path = base_path();

  // Expose KalaStatic's destination build path.
  $build_path = $base_path . kalastatic_path_to_kalastatic_html();

  // Let Twig know about the new global variables.
  // TODO: Reintroduce base_path once url() is used in PROGMI.
  //$twig->addGlobal('base_path', $base_path);
  $twig->addGlobal('build_path', $build_path);
}
